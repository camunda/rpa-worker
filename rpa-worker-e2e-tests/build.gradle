import groovy.transform.stc.ClosureParams
import groovy.transform.stc.SimpleType

import java.nio.file.Files
import java.nio.file.Paths
import java.time.Duration
import java.time.Instant

plugins {
	id 'java'
	id 'groovy'
	id 'idea'
	alias(libs.plugins.spring.boot)
	alias(libs.plugins.spring.dependencyManagement)
	id 'rpa-worker.enable-preview'
	alias(libs.plugins.testLogger)
}

java {
	toolchain {
		languageVersion = JavaLanguageVersion.of(24)
	}
}

springBoot {
	mainClass = "io.camunda.rpa.worker.e2e.RpaWorkerE2ETestsApplication"
}

configurations {
	compileOnly {
		extendsFrom annotationProcessor
	}
}

repositories {
	mavenCentral()
	maven {
		url 'https://gitlab.com/api/v4/projects/50731191/packages/maven'
	}
}

dependencies {
	implementation project(":rpa-worker-common")
	implementation libs.spring.boot.starter.webflux

	implementation libs.camundaStarter
	implementation libs.vavr
	implementation libs.jackson.dataFormatYaml
	implementation libs.reactiveFeign
	implementation libs.javaSemver
	implementation libs.slf4j.api

	// TODO: Forced update to transitive dependency - remove when no longer required
	implementation libs.commons.lang

	developmentOnly libs.spring.boot.devtools
	annotationProcessor libs.spring.boot.configurationProcessor
	
	compileOnly libs.lombok
	annotationProcessor libs.lombok

	testImplementation libs.reactor.test
	testImplementation libs.spock.core
	testImplementation libs.groovy.json
	testImplementation libs.groovy.nio
	testImplementation libs.groovy.templates
	testImplementation libs.mockwebserver
	testImplementation libs.spring.boot.starter.test
	testImplementation libs.spock.spring

	testRuntimeOnly libs.junit.platformLauncher
	testRuntimeOnly libs.byteBuddy
	testRuntimeOnly libs.objenesis
}

tasks.withType(Test).configureEach {
	useJUnitPlatform()

	java.nio.file.Path workerPath = project.rootDir.toPath().resolve("workerpath.txt")
	if (Files.exists(workerPath))
		environment("CAMUNDA_RPA_E2E_PATHTOWORKER", Paths.get(workerPath.text.trim()).toAbsolutePath().toString())
	

//	systemProperty("camunda.rpa.e2e.worker.override", "c8-v87-snapshot-dev-mine")
//	systemProperty("camunda.rpa.e2e.worker.override", "c8-v88-snapshot-dev-mine")

//	systemProperty("camunda.rpa.e2e.worker.override", "c8-v87-snapshot-local")
//	systemProperty("camunda.rpa.e2e.worker.override", "c8-v87-snapshot-2-local")

//	systemProperty("camunda.rpa.e2e.worker.override", "c8-v88-snapshot-local")
//	systemProperty("camunda.rpa.e2e.worker.override", "c8-v88-snapshot-newchart-local")
//	systemProperty("camunda.rpa.e2e.worker.override", "c8-v88-snapshot-newchart2e2e-local")

//	systemProperty("camunda.rpa.e2e.worker.override", "c8run")
}


tasks.register("updateHosts") {
	doLast {
		String hosts = ["camunda.local", "zeebe.camunda.local", "rpa-worker.local"].collect {
			"127.0.0.1 \t ${it}"
		}.join("\n")
		"sudo tee -a /etc/hosts".execute().tap {
			wrapProcess(it) {
				outputStream.withWriter { w ->
					w.write("\n" + hosts)
				}
			}
		}
	}
}

tasks.register("installK3s") {
	dependsOn updateHosts
	
	doLast {
		java.nio.file.Path k3sScript = Files.createTempFile("install-k3s", ".sh")
		k3sScript.text = "https://get.k3s.io".toURL().text
		
		ProcessBuilder pb = new ProcessBuilder("sudo", "-E", "sh", k3sScript.toAbsolutePath().toString())
		pb.environment()['K3S_KUBECONFIG_MODE'] = "644"
		wrapProcess(pb.start())
		sleep(10_000)
		
		waitForWithTimeout(
				"k3s kubectl wait --for=condition=Ready node -l node.kubernetes.io/instance-type",
				Duration.ofMinutes(2),
				"Cluster did not become ready")
	}
}

tasks.register("installCamunda") {
	dependsOn installK3s

	doLast {
		wrapProcess("k3s kubectl create ns camunda".execute())

		if(System.getenv("CAMUNDA_VERSION") == "v88")
			["v88_bootstrap_credentials", "v88_gw_ingress", "v88_gw_svc"].each {
				wrapProcess("k3s kubectl apply -n camunda -f rpa-worker-e2e-tests/${it}.yaml".execute())
			}

		wrapProcess("k3s kubectl apply -f rpa-worker-e2e-tests/camunda_${System.getenv("CAMUNDA_VERSION")}.helmrelease.yaml".execute())

		if (System.getenv("CAMUNDA_VERSION") == "v88")
			waitForWithTimeout([
					"k3s", "kubectl", "patch", "-n", "camunda", "sts/camunda-zeebe", "--patch",
					'{"spec":{"template":{"spec":{"hostAliases":[{"ip":"10.42.1.1", "hostnames":["camunda.local"]}]}}}}'],
					Duration.ofMinutes(1),
					"Zeebe STS did not appear")
		
		wrapProcess("ip a".execute())

		waitForWithTimeout(
				"k3s kubectl wait -n camunda --for=condition=Ready pod -l app=camunda-platform",
				Duration.ofMinutes(10),
				"Application stack did not become ready") {
			
			wrapProcess("k3s kubectl get pods -n camunda".execute())
		}
	}
}

tasks.register("patchCamunda") {
	onlyIf { System.getenv("CAMUNDA_VERSION") == "v88" }
	dependsOn installCamunda
	
	doLast {
	}
}

tasks.register("deployWorkerContainer") {
	dependsOn installCamunda
	
	doLast {
		java.nio.file.Path workerSpec = Paths.get("rpa-worker-e2e-tests/rpa-worker.deployment.yaml")
		String orig = workerSpec.text
		workerSpec.text = orig.replaceAll("999_DIGEST_999", System.getenv("WORKER_IMAGE_DIGEST"))
		wrapProcess("k3s kubectl create ns rpa-worker".execute())
		wrapProcess("k3s kubectl apply -n rpa-worker -f rpa-worker-e2e-tests/rpa-worker.deployment.yaml".execute())
		
		waitForWithTimeout(
				"k3s kubectl wait -n rpa-worker --for=condition=Ready pod -l app=rpa-worker",
				Duration.ofMinutes(10),
				"RPA Worker did not become ready") {

			wrapProcess("k3s kubectl get pods -n rpa-worker".execute())
		}
	}
}

tasks.register("configureClientSecret") {
	dependsOn installCamunda
	
	doLast {
		String b64Secret = wrapProcessForResult("k3s kubectl get secret -n camunda camunda-zeebe-identity-secret -o jsonpath={.data.zeebe-secret}".execute())
		String secret = new String(b64Secret.decodeBase64())
		tasks.withType(Test).configureEach {
			it.environment("CAMUNDA_CLIENT_AUTH_CLIENTSECRET", secret)
		}
	}
}

tasks.withType(Test).configureEach {
	if(System.getenv("CI")) {
		it.dependsOn deployWorkerContainer
		it.dependsOn configureClientSecret
	}
}

static void wrapProcess(Process p, @ClosureParams(value = SimpleType, options = ["java.lang.Process"]) Closure withProcessFn = {}) {
	p.consumeProcessOutput(System.out, System.err)
	withProcessFn(p)
	int exit = p.waitFor()
	assert exit == 0
}

static String wrapProcessForResult(Process p, @ClosureParams(value = SimpleType, options = ["java.lang.Process"]) Closure withProcessFn = {}) {
	p.consumeProcessErrorStream(System.err)
	withProcessFn(p)
	int exit = p.waitFor()
	assert exit == 0
	return p.text
}

static void waitForWithTimeout(def waitForCmd, Duration timeout, String failMsg, Closure eachLoop = {}) {
	Instant endTime = Instant.now() + timeout
	int waitExit = -1
	while (Instant.now() < endTime) {
		waitExit = (waitForCmd instanceof String ? waitForCmd.execute() : new ProcessBuilder((List<String>) waitForCmd).start()).with {
			consumeProcessOutput(System.out, System.err)
			return waitFor()
		}
		if (waitExit == 0) break
		eachLoop()
	}
	if (waitExit != 0)
		throw new GradleException(failMsg)
}